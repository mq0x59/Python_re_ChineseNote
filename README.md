### 前言

本笔记借鉴于以下网址：
> [鱼C工作室](https://fishc.com.cn)
> <https://docs.python.org/zh-cn/3/library/re.html>

---

### 概述

正则表达式(称为RE，或正则，或正则表达式模式)本质上是嵌入在Python中的一种微小的、高度专业化的编程语言，可通过re模块获得。使用正则表达式，你需要指定一些规则来描述那些你希望匹配的字符串集合；此集合可能包含英语句子、电子邮件地址、TeX命令，或你喜欢的任何内容。

正则表达式语言相对较小且受限制，因此并非所有可能的字符串处理任务都可以使用正则表达式完成。还有一些任务可以用正则表达式完成，但表达式变得非常复杂。在这些情况下，你最好编写Python代码来进行处理；虽然Python代码比精心设计的正则表达式慢，但它也可能更容易理解。

---

### 简单模式

我们首先要了解最简单的正则表达式。由于正则表达式用于对字符串进行操作，因此我们将从最常见的任务开始：匹配字符。

---

##### 匹配字符

大多数字母和字符只会匹配自己。例如：正则表达式`test`将完全匹配字符串`test`。(你可以启用不区分大小写的模式，让这个正则匹配`Test`或`TEST`，这个后面会详细说。)
当然这条规则有例外；一些字符是特殊的，称为元字符(metacharacters)，它们并不能匹配自身，它们定义了字符类、子组匹配和模式重复次数等。会用很大的篇幅讨论各种元字符及其功能。
> 这是元字符的完整列表：
> . ^ $ * + ? { } [ ] \ | ( )

方括号`[]`，用于指定字符类，可以单独列出字符，也可以通过给出两个字符并用`-`标记将它们分开来表示一系列字符。`[abc]`将匹配任何字符`a`、`b`或`c`；这与`a-c`相同，它使用一个范围来表示同一组字符。如果你只想匹配小写字母，你的正则是`[a-z]`。
在方括号中的元字符不生效，例如，`[akm$]`将匹配`a`、`k`、`m`或`$`中的任意字符；`$`通常是一个元字符，但在一个字符类中它被剥夺了特殊性。
还可以通过`^`匹配设置的字符类中未列出的字符，在类的开头添加`^`，`[^5]`会匹配除了`5`之外的任何字符，但`[5^]`将匹配`5`或`^`。

反斜杠`\`是最重要的元字符，反斜杠后面可以跟各种字符，以指示各种特殊序列。它也用于转移所有元字符，如果你需要匹配`[`或`\`，你可以在它们前面加一个反斜杠来移除它们的特殊含义：`\[`或`\\`。

注：一些以`\`开头的特殊序列表示通常有用的预定义字符集，例如数字集、字母集或任何非空格的集合。让我们举个例子：`\w`匹配任何字母数字字符。如果正则表达式模式以字节类表示，这相当于类`[a-zA-Z0-9]`。如果正则表达式是一个字符串，`\w`将匹配由unicodedata模块提供的Unicode数据库中标记为字母的所有字符。通过在编译正则表达式时提供re.ASCII标志，可以在字符串模式中使用更为受限制的`\w`定义。

以下为一些特殊序列的表格：
| 特殊字符 | 含义 |
| :---: | :---- |
| `\d` | 匹配任何十进制数字；等价于类`[0-9]` |
| `\D` | 匹配任何非十进制数字字符；等价于类`[^0-9]` |
| `\s` | 匹配任何空白字符；等价于类`[\t\n\r\f\v]` |
| `\S` | 匹配任何非空白字符；等价于类`[^\t\n\r\f\v]` |
| `\w` | 匹配任何字母与数字字符；相当于类`[a-zA-Z0-9]` |
| `\W` | 匹配任何非字母与数字字符；相当于类`[^a-zA-Z0-9]` |

这些序列可以包含在字符类中。例如，`[\s,.]`是一个匹配任何空格字符的字符类或者`,`，或`.`。

`.`匹配除换行符之外的任何内容，并且有一个可选模式(re.DOTALL)甚至可以匹配换行符。`.`常用于你想匹配“任何字符”的地方。

重复
能够匹配不同的字符集合是正则表达式可以做的第一件事，这对于字符串可用方法来说是不可能的。但是，如果这是正则表达式的唯一额外功能，那么它们就不会有太大的优势。另一个功能是你可以指定正则的某些部分必须重复一定次数。

重复中我们要了解的第一个元字符是`*`。`*`与字面字符`*`不匹配；相反，它指定前一个字符可以匹配零次或多次，而不是恰好一次。
例如，`ca*t`将匹配`ct`(0个`a`字符)，`caaat`(3个`a`字符)，等等。

类似`*`这样的重复是贪婪的；当重复正则时，匹配引擎将尝试尽可能多地重复它。如果模式地后续部分不匹配，则匹配引擎将回退并以较少的重复次数再次尝试。

通过一个逐步的例子来讲解“贪婪”，让我们考虑`a[bcd]*b`。这个正则匹配字母`a`，类`[bcd]`中的零或多个字母，最后以`b`结尾。现在想象一下这个正则与字符串`abcbd`匹配。
| 步骤 | 匹配 | 说明 |
| :---- | :---- | :---- |
| 1 | `a` | 正则中的`a`匹配。 |
| 2 | `abcbd` | 引擎尽可能多地匹配`[bcd]*`，直到字符串结束。 |
| 3 | 失败 | 引擎尝试匹配`b`，但是当前位置位于字符串结束，所以匹配失败。 |
| 4 | `abcb` | 回退一次，`[bcd]*`少匹配一个字符。 |
| 5 | 失败 | 再次尝试匹配`b`，但是当前位置是最后一个字符`d`。 |
| 6 | `abc` | 再次回退，所以`[bcd]*`只匹配`bc`。 |
| 7 | `abcb` | 再试一次`b`。这次当前位置的字符是`b`，所以它成功了。 |

正则现在已经结束了，它已经匹配了`abcb`。这演示了匹配引擎最初如何进行，如果没有找到匹配，它将逐步回退并一次又一次地重试正则的其余部分。它将回退，知道它为`[bcd]*`尝试零匹配，如果随后失败，引擎将断定该字符串与正则完全不匹配。

---

### 正则表达式语法

正则表达式（或 RE）指定了一组与之匹配的字符串；模块内的函数可以检查某个字符串是否与给定的正则表达式匹配（或者正则表达式是否匹配到字符串，这两种说法含义相同）。

正则表达式可以拼接；如果 A 和 B 都是正则表达式，则 AB 也是正则表达式。通常，如果字符串 p 匹配 A，并且另一个字符串 q 匹配 B，那么 pq 可以匹配 AB。除非 A 或者 B 包含低优先级操作，A 和 B 存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。

正则表达式可以包含普通或者特殊字符。绝大部分普通字符，比如 `'A'`, `'a'`, 或者 `'0'`，都是最简单的正则表达式。它们就匹配自身。你可以拼接普通字符，所以 `last` 匹配字符串 `'last'`. 

有些字符，比如 `'|'` 或者 `'('`，属于特殊字符。特殊字符既可以表示它的普通含义，也可以影响它旁边的正则表达式的解释。

重复修饰符 (`*`, `+`, `?`, `{m,n}`, 等) 不能直接嵌套。这样避免了非贪婪后缀 `?` 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。 比如，表达式`(?:a{6})*`匹配6个 `'a'` 字符重复任意次数.

---
